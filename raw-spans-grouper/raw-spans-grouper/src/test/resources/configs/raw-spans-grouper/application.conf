service.name = raw-spans-grouper
service.admin.port = 8051

main.class = org.hypertrace.core.rawspansgrouper.RawSpansGrouper

span.type = rawSpan
input.topic = "jaeger-spans"
output.topic = "structured-traces-from-raw-spans"
bypass.output.topic = "structured-traces-from-raw-spans-bypass"
raw.logs.output.topic = "raw-logs"

precreate.topics = false

kafka.streams.config = {
  application.id = raw-spans-to-structured-traces-grouping-job
  num.stream.threads = 2
  topic.cleanup.policy = "delete,compact"
  replication.factor = 3
  bootstrap.servers = "localhost:9092"
  schema.registry.url = "mock://localhost:8081"
  rocksdb.config.setter = org.hypertrace.core.kafkastreams.framework.rocksdb.RocksDBStateStoreConfigSetter
  rocksdb.block.cache.size = 33554432
  rocksdb.write.buffer.size = 8388608
  rocksdb.max.write.buffers = 2
  rocksdb.cache.index.and.filter.blocks = true
  value.subject.name.strategy = "io.confluent.kafka.serializers.subject.TopicRecordNameStrategy"
}

group.partitioner = {
  enabled = false
  service.host = localhost
  service.port = 50104
}

processor {
  #defaultTenantId = ${?DEFAULT_TENANT_ID}
  late.arrival.threshold.duration = 365d

  # Configuration for dropping certain attributes that are captured by agent, but doesn't require in
  # the processing pipeline.
  #
  # allowed.attributes.prefixes : the list of prefixes that should match for which allowed keys
  # prefixed.matched.allowed.attributes : allowed keys from the subset of keys where prefix matched
  #
  # If either of config is empty allowed.attributes.prefixes or prefixed.matched.allowed.attributes,
  # it will not drop any attributes.
  # The above configuration doesn't impact if the key doesn't start with prefix.
  allowed.attributes.prefixes = []
  prefixed.matched.allowed.attributes = []
}

span.window.store.retention.time.mins = 60
span.window.store.retention.time.mins = ${?SPAN_WINDOW_STORE_RETENTION_TIME_MINS}
span.window.store.segment.size.mins = 20
span.window.store.segment.size.mins = ${?SPAN_WINDOW_STORE_SEGMENT_SIZE_MINS}

default.max.span.count = 6
max.span.count = {
  tenant1 = 5
}

span.groupby.session.window.interval = 5

span.groupby.session.window.graceperiod.ms = 100

dataflow.metriccollection.sampling.percent = 10.0


processor {
  tenantIdTagKey = "tenant-id"
  #defaultTenantId = "__default"
}

processor {
  spanDropFilters = [
    [
      {
        "tagKey": "http.method",
        "operator": "EQ",
        "tagValue": "GET"
      },
      {
        "tagKey": "http.url",
        "operator": "CONTAINS",
        "tagValue": "health"
      }
    ],
    [
      {
        "tagKey": "grpc.url",
        "operator": "NEQ",
        "tagValue": "Sent.TestServiceGetEchos"
      }
    ],
    [
      {
        "tagKey": "ht.operation.name",
        "operator": "EQ",
        "tagValue": "/api/"
      },
      {
        "tagKey": "span.kind",
        "operator": "NOT_EXISTS",
        "tagValue": ""
      }
    ]
  ]
}

processor {
  bypass.key = "test.bypass"
  late.arrival.threshold.duration = "1d"

  # Configuration for dropping certain attributes that are captured by agent, but doesn't require in
  # the processing pipeline.
  #
  # allowed.attributes.prefixes : the list of prefixes that should match for which allowed keys
  # prefixed.matched.allowed.attributes : allowed keys from the subset of keys where prefix matched
  #
  # If either of config is empty allowed.attributes.prefixes or prefixed.matched.allowed.attributes,
  # it will not drop any attributes.
  # The above configuration doesn't impact if the key doesn't start with prefix.
  allowed.attributes.prefixes = ["http.request.header.x-", "http.response.header.x-"]
  prefixed.matched.allowed.attributes = ["http.request.header.x-allowed-1", "http.response.header.x-allowed-2"]
}

clients = {
  config.service.config = {
    host = localhost
    port = 50101
  }
}

span.rules.exclude {
  cache = {
    refreshAfterWriteDuration = 3m
    expireAfterWriteDuration = 5m
  }
}

rate.limit.config = []
